//=============================================================================
//
// クライアント処理 [tcp_client.cpp]
// Author : 二階堂汰一
//
//=============================================================================

//*****************************************************************************
// 警告制御
//*****************************************************************************
#define _CRT_SECURE_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS

//*****************************************************************************
// ヘッダファイルのインクルード
//*****************************************************************************
#include <stdio.h>
#include <WinSock2.h>
#include "tcp_client.h"
#include "tcp_listener.h"

//=============================================================================
// コンストラクタ
//=============================================================================
CTcpClient::CTcpClient()
{
	m_sock = -1;
}

//=============================================================================
// デストラクタ
//=============================================================================
CTcpClient::~CTcpClient()
{
}

//=============================================================================
// 生成処理関数
//=============================================================================
CTcpClient * CTcpClient::Create(SOCKET sock)
{
	//クライアントのメモリ確保
	CTcpClient *pTcpClient = new CTcpClient;
	if (pTcpClient->Init(sock) == false)
	{
		delete pTcpClient;
		pTcpClient = NULL;
	}
	return pTcpClient;
}

//=============================================================================
// 初期化処理関数
//=============================================================================
bool CTcpClient::Init(SOCKET sock)
{
	m_sock = sock;
	return true;
}

//=============================================================================
// 送信処理関数
//=============================================================================
int CTcpClient::Send(char *pSendData, int nSendDataSize)
{
	if (m_sock < 0)
	{
		return 0;
	}
	int nSendSize = send(m_sock, pSendData, nSendDataSize, 0);
	return nSendSize;
}

//=============================================================================
// 受信処理関数
//=============================================================================
int CTcpClient::Recv(char *pRecvBuf, int nRecvBufSize)
{
	//バッファを0クリア
	memset(pRecvBuf, 0, nRecvBufSize);
	int nRecvSize = recv(m_sock, pRecvBuf, nRecvBufSize, 0);
	if (nRecvBufSize <= 0)
	{
		closesocket(m_sock);
	}
	return nRecvBufSize;
}

//=============================================================================
// 切断処理関数
//=============================================================================
void CTcpClient::Close()
{
	if (m_sock < 0)
	{
		return;
	}
	closesocket(m_sock);
	m_sock = -1;
}


//=============================================================================
// 破棄処理関数
//=============================================================================
void CTcpClient::Release(void)
{
	Close();
	delete this;
}